<!DOCTYPE html>
<html>
<head>
  <title>Football Decision Training Game (iPad)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
      margin: 0;
      height: 100vh;
      overflow: hidden;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    canvas {
      border: 2px solid #000;
      max-width: 90vw;
      max-height: 60vh; /* Adjusted for dynamic sizing */
      touch-action: none;
      z-index: 5;
    }
    #instructions, #level, #score, #time {
      margin: 5px;
      text-align: center;
      font-size: 3vw; /* Dynamic font size */
    }
    #color-buttons {
      display: none;
      z-index: 10;
    }
    .color-button {
      padding: 2vw 4vw;
      margin: 1vw;
      font-size: 2.5vw;
      cursor: pointer;
      touch-action: manipulation;
    }
    #start-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    #start-popup {
      background: white;
      padding: 4vw;
      border-radius: 10px;
      max-width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      text-align: left;
      font-size: 2.5vw;
      line-height: 1.5;
    }
    #play-button {
      display: block;
      margin: 4vw auto 0;
      padding: 2vw 4vw;
      font-size: 3vw;
      background-color: #28a745;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      touch-action: manipulation;
    }
    @media (max-width: 768px) {
      #instructions, #score, #time, #level {
        font-size: 2.5vw;
      }
      #start-popup {
        font-size: 2vw;
      }
      .color-button, #play-button {
        padding: 1.5vw 3vw;
        font-size: 2vw;
      }
    }
  </style>
</head>
<body>
  <div id="start-screen">
    <div id="start-popup">
      <h2>Football Decision Training Game</h2>
      <p><strong>Premise:</strong> This game trains your mental processing speed and "quiet eye" (focused visual attention) to make fast, accurate football passing decisions, mimicking elite-level play.</p>
      <h3>How to Play:</h3>
      <ul>
        <li><strong>Level 1 (Passing):</strong> Tap the teammate (white circle, yellow outline) in the best position to pass to, avoiding opponents (red circles). Time: 3s. Score 10 points to advance.</li>
        <li><strong>Level 2 (Ball Tracking):</strong> Watch a fast, randomly moving ball for 10 seconds to train visual tracking. No tapping required. Advances automatically.</li>
        <li><strong>Level 3 (Stroop Test):</strong> A word (e.g., "Blue" in white) appears. Tap the button matching the text color, not the word. Complete 10 correct answers to advance.</li>
        <li><strong>Level 4 (Advanced Passing):</strong> Like Level 1, but with more opponents, 2s timer, and an amber teammate (avoid). Score 10 points to advance.</li>
        <li><strong>Level 5 (Elite Passing):</strong> Toughest level with 3-5 opponents, 1.5s timer, smaller targets, and amber distractors. Score 10 points to loop to Level 1.</li>
      </ul>
      <p><strong>Scoring:</strong> Earn 1 point per correct action in Levels 1, 3, 4, 5. Incorrect actions or timeouts reset the scenario. Use quiet eye: focus on highlighted targets.</p>
      <button id="play-button" ontouchstart="startGame()">Play</button>
    </div>
  </div>
  <div id="instructions">Tap the teammate in the best position to pass to.</div>
  <div id="level">Level: 1</div>
  <div id="score">Score: 0</div>
  <div id="time">Time Left: 3.0s</div>
  <div id="color-buttons"></div>
  <script>
    let level = 1;
    let score = 0;
    let timeLeft = 3;
    let gameState = 'start';
    let players = [];
    let correctPlayer = null;
    let startTime;
    let ball = { x: 0, y: 0 };
    let stroopWords = [
      { word: 'Red', color: 'blue' }, { word: 'Blue', color: 'white' },
      { word: 'Green', color: 'red' }, { word: 'White', color: 'green' },
      { word: 'Yellow', color: 'red' }
    ];
    let stroopIndex = 0;
    let correctColor = '';
    let levelProgress = 0;
    let canvas;

    function setup() {
      updateCanvasSize();
      canvas = createCanvas(canvasWidth, canvasHeight);
      canvas.style('touch-action', 'none');
      textAlign(CENTER);
      updateTextSize();
      canvas.elt.addEventListener('touchstart', handleTouch, { passive: false });
      canvas.elt.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
      canvas.elt.addEventListener('touchend', (e) => e.preventDefault(), { passive: false });
      select('#play-button').elt.addEventListener('touchstart', startGame, { passive: false });
      resetLevel();
    }

    function updateCanvasSize() {
      window.canvasWidth = min(windowWidth * 0.9, windowHeight * 0.6);
      window.canvasHeight = canvasWidth * 2 / 3;
    }

    function updateTextSize() {
      textSize(canvasWidth / 20);
    }

    function windowResized() {
      updateCanvasSize();
      resizeCanvas(canvasWidth, canvasHeight);
      updateTextSize();
    }

    function startGame(event) {
      if (event) event.preventDefault();
      select('#start-screen').hide();
      gameState = 'playing';
      startTime = millis();
    }

    function handleTouch(event) {
      event.preventDefault();
      if (gameState === 'start') return;
      let rect = canvas.elt.getBoundingClientRect();
      let touchX = (event.touches[0].clientX - rect.left) * (canvasWidth / rect.width);
      let touchY = (event.touches[0].clientY - rect.top) * (canvasHeight / rect.height);
      if (level === 1 || level === 4 || level === 5) {
        handlePassingGameTouch(touchX, touchY);
      } else if (level === 3) {
        handleStroopTestTouch(touchX, touchY);
      }
      console.log('Touch at:', touchX, touchY, 'Canvas:', canvasWidth, canvasHeight);
    }

    function draw() {
      if (gameState === 'start') {
        background(0, 128, 0);
        fill(255);
        text('Tap Play to start', width / 2, height / 2);
        return;
      }
      background(0, 128, 0);
      if (level === 1 || level === 4 || level === 5) {
        drawPassingGame();
      } else if (level === 2) {
        drawBallTracking();
      } else if (level === 3) {
        drawStroopTest();
      }
      select('#level').html(`Level: ${level}`);
      select('#score').html(`Score: ${score}`);
    }

    function drawPassingGame() {
      let timeLimit = level === 1 ? 3 : level === 4 ? 2 : 1.5;
      let circleSize = level === 5 ? 25 : 35; // Increased for touch
      fill(255);
      ellipse(width / 2, height - 50, circleSize, circleSize);
      for (let player of players) {
        fill(player.isOpponent ? 'red' : player.isAmber ? 'orange' : 'white');
        ellipse(player.x, player.y, circleSize, circleSize);
        if (player === correctPlayer) {
          noFill();
          stroke(255, 255, 0);
          strokeWeight(4);
          ellipse(player.x, player.y, circleSize + 6, circleSize + 6);
          noStroke();
        }
      }
      if (gameState === 'playing') {
        timeLeft = timeLimit - (millis() - startTime) / 1000;
        select('#time').html(`Time Left: ${max(0, timeLeft.toFixed(1))}s`);
        if (timeLeft <= 0) {
          gameState = 'timeout';
          select('#instructions').html('Timeâ€™s up! Tap to try again.');
        }
      }
      if (gameState === 'correct') {
        fill(255);
        text('Correct! Tap to continue.', width / 2, height / 2);
      } else if (gameState === 'wrong') {
        fill(255);
        text('Wrong! Tap to try again.', width / 2, height / 2);
      }
    }

    function drawBallTracking() {
      if (gameState === 'playing') {
        ball.vx = random(-9, 9); // Random velocity per frame
        ball.vy = random(-9, 9);
        ball.x += ball.vx;
        ball.y += ball.vy;
        if (ball.x < 25 || ball.x > width - 25) ball.vx *= -1;
        if (ball.y < 25 || ball.y > height - 25) ball.vy *= -1;
        timeLeft = 10 - (millis() - startTime) / 1000;
        select('#time').html(`Time Left: ${max(0, timeLeft.toFixed(1))}s`);
        if (timeLeft <= 0) {
          level = 3;
          levelProgress = 0;
          resetLevel();
          updateInstructions();
        }
      }
      fill(255);
      ellipse(ball.x, ball.y, 35, 35);
    }

    function drawStroopTest() {
      select('#time').html('');
      let current = stroopWords[stroopIndex];
      fill(current.color);
      text(current.word.toUpperCase(), width / 2, height / 2);
      if (gameState === 'correct') {
        fill(255);
        text('Correct! Tap to continue.', width / 2, height / 2 + 40);
      } else if (gameState === 'wrong') {
        fill(255);
        text('Wrong! Tap to try again.', width / 2, height / 2 + 40);
      }
    }

    function handlePassingGameTouch(touchX, touchY) {
      let circleSize = level === 5 ? 25 : 35;
      if (gameState === 'playing') {
        for (let player of players) {
          if (dist(touchX, touchY, player.x, player.y) < circleSize / 2) {
            if (player === correctPlayer) {
              score++;
              levelProgress++;
              gameState = 'correct';
              select('#instructions').html('Correct! Tap to continue.');
              checkLevelProgress();
            } else {
              gameState = 'wrong';
              select('#instructions').html('Wrong! Tap to try again.');
            }
          }
        }
      } else {
        resetLevel();
        gameState = 'playing';
        startTime = millis();
        updateInstructions();
      }
    }

    function handleStroopTestTouch(touchX, touchY) {
      if (gameState === 'correct' || gameState === 'wrong') {
        resetLevel();
        gameState = 'playing';
        startTime = millis();
        updateInstructions();
      }
    }

    function resetLevel() {
      if (level === 1 || level === 4 || level === 5) {
        resetPassingGame();
      } else if (level === 2) {
        resetBallTracking();
      } else if (level === 3) {
        resetStroopTest();
      }
      timeLeft = level === 1 ? 3 : level === 4 ? 2 : level === 5 ? 1.5 : 10;
    }

    function resetPassingGame() {
      players = [];
      let numPlayers = level === 1 ? random(3, 6) : level === 4 ? random(4, 7) : random(5, 8);
      let numOpponents = level === 1 ? random(1, 3) : level === 4 ? random(2, 4) : random(3, 5);
      let spacing = level === 5 ? 40 : 60;
      for (let i = 0; i < numPlayers; i++) {
        let isOpponent = i < numOpponents;
        let isAmber = (level >= 4 && i === numOpponents && random() > 0.5);
        let x, y;
        do {
          x = random(50, width - 50);
          y = random(50, height - 100);
        } while (players.some(p => dist(x, y, p.x, p.y) < spacing));
        players.push({ x, y, isOpponent, isAmber });
      }
      let teammates = players.filter(p => !p.isOpponent && !p.isAmber);
      correctPlayer = teammates.reduce((best, curr) => {
        let minDistToOpponent = min(players.filter(p => p.isOpponent).map(p => dist(curr.x, curr.y, p.x, p.y)));
        let bestDist = best ? min(players.filter(p => p.isOpponent).map(p => dist(best.x, best.y, p.x, p.y))) : 0;
        return minDistToOpponent > bestDist ? curr : best;
      }, null);
      select('#color-buttons').hide();
    }

    function resetBallTracking() {
      ball.x = width / 2;
      ball.y = height / 2;
      select('#color-buttons').hide();
      gameState = 'playing';
      startTime = millis();
    }

    function resetStroopTest() {
      stroopIndex = floor(random(stroopWords.length));
      correctColor = stroopWords[stroopIndex].color;
      let buttons = ['red', 'blue', 'white', 'green', 'yellow'];
      shuffle(buttons);
      let buttonDiv = select('#color-buttons');
      buttonDiv.html('');
      for (let color of buttons) {
        let button = createButton(color.toUpperCase());
        button.style('background-color', color);
        button.style('color', color === 'white' ? 'black' : 'white');
        button.class('color-button');
        button.elt.addEventListener('touchstart', (e) => {
          e.preventDefault();
          if (gameState === 'playing' && level === 3) {
            if (color === correctColor) {
              score++;
              levelProgress++;
              gameState = 'correct';
              select('#instructions').html('Correct! Tap to continue.');
              checkLevelProgress();
            } else {
              gameState = 'wrong';
              select('#instructions').html('Wrong! Tap to try again.');
            }
          }
        });
        button.mousePressed(() => {
          if (gameState === 'playing' && level === 3) {
            if (color === correctColor) {
              score++;
              levelProgress++;
              gameState = 'correct';
              select('#instructions').html('Correct! Tap to continue.');
              checkLevelProgress();
            } else {
              gameState = 'wrong';
              select('#instructions').html('Wrong! Tap to try again.');
            }
          }
        });
        buttonDiv.child(button);
      }
      buttonDiv.show();
    }

    function checkLevelProgress() {
      if ((level === 1 || level === 4 || level === 5) && levelProgress >= 10) {
        level = level === 5 ? 1 : level + 1;
        levelProgress = 0;
        resetLevel();
        updateInstructions();
      } else if (level === 3 && levelProgress >= 10) {
        level = 4;
        levelProgress = 0;
        resetLevel();
        updateInstructions();
      }
    }

    function updateInstructions() {
      if (level === 1) {
        select('#instructions').html('Tap the teammate (white) in the best position to pass to.');
      } else if (level === 2) {
        select('#instructions').html('Watch the fast-moving ball to train visual tracking.');
      } else if (level === 3) {
        select('#instructions').html('Tap the button matching the color of the word, not the word itself.');
      } else if (level === 4) {
        select('#instructions').html('Tap the best teammate (white, avoid amber) to pass to.');
      } else if (level === 5) {
        select('#instructions').html('Elite mode: Tap the best teammate (white, avoid amber) quickly!');
      }
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        let j = floor(random(i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }
  </script>
</body>
</html>
